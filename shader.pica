; Hopefully, a PICA200 vertex shader (less and less basic by the day)

; Model matrix uniform - loaded by the renderer before rendering a given model
.fvec modelMtx[4]

; Camera matrix uniform - loaded by the renderer before any given render
.fvec camMtx[4]

; Projection matrix uniform - loaded by the renderer before any given render
.fvec projMtx[4]

; Light colour - currently unused, but will be loaded by the renderer before any given render
.fvec lightClr

; Material properties uniforms - loaded by the renderer every time the material changes
; Emission colour - light emitted by the object on its own
.fvec mat_emi
; Ambient colour - simulated light scattered around the entire scene (unused right now)
.fvec mat_amb
; Diffuse colour - shading (unused right now)
.fvec mat_dif
; Specular colour - shininess, handled separately by the GPU I think (unused right now)
.fvec mat_spe

; Useful constants
; Define a vec4 with various useful values as the elements, then set aliases to get them out
.constf useful_constants(0.0, 1.0, -1.0, -0.5)
; All zeroes - copy out the first element in all 4 places
.alias zeroes useful_constants.xxxx
; All ones - copy out the second element in all 4 places
.alias ones useful_constants.yyyy
; All negative ones
.alias neg_ones useful_constants.zzzz
; All negative halves
.alias neg_halves useful_constants.wwww
; (1.0, 0.0, 0.0, 0.0)
.alias ozzz useful_constants.yxxx

.constf more_useful_constants(0.0, 1.0, 1.0, 0.5)
; All positive halves
.alias halves more_useful_constants.wwww

; Output registers, written to by the shader
.out outpos pos
.out outcol clr
.out outtex texcoord0
.out outview view
.out outnq normalquat

; Inputs (passed in through v0..=v15, with aliases for convenience)
.in inpos
.in intex
.in innrm

; The actual shader function
.proc main
    ; r0.xyz = xyz components of inpos
    mov r0.xyz, inpos

    ; r0.w = 1.0 from ones constant alias
    mov r0.w, ones

    ; r1 = modelMatrix * r0
    ; perform matrix * vector multiplication via dot product instruction one component at a time
    dp4 r1.x, modelMtx[0], r0
    dp4 r1.y, modelMtx[1], r0
    dp4 r1.z, modelMtx[2], r0
    dp4 r1.w, modelMtx[3], r0

    ; r2 = cameraMatrix * r1
    dp4 r2.x, camMtx[0], r1
    dp4 r2.y, camMtx[1], r1
    dp4 r2.z, camMtx[2], r1
    dp4 r2.w, camMtx[3], r1

    ; outview = -r2
    mov outview, -r1
    ;mov outview, -r2

    ; outpos = projectionMatrix * r2
    dp4 outpos.x, projMtx[0], r2
    dp4 outpos.y, projMtx[1], r2
    dp4 outpos.z, projMtx[2], r2
    dp4 outpos.w, projMtx[3], r2

    ; outtex = intex
    mov outtex, intex

    ; r14 = modelMatrix * innrm
    ; transform the normal vector with the model matrix
    dp3 r15.x, modelMtx[0], innrm
    dp3 r15.y, modelMtx[1], innrm
    dp3 r15.z, modelMtx[2], innrm
    dp3 r14.x, camMtx[0], r15
    dp3 r14.y, camMtx[1], r15
    dp3 r14.z, camMtx[2], r15
    ; r14 = r14 * sqrt(r14.x)
    dp3 r6.x, r14, r14
    rsq r6.x, r6.x
    mul r14.xyz, r14.xyz, r6.x

    mov r0, ozzz
    add r4, ones, r14.z
    mul r4, halves, r4
    cmp zeroes, ge, ge, r4.x
    rsq r4, r4.x
    mul r5, halves, r14
    jmpc cmp.x, degenerate

    rcp r0.z, r4.x
    mul r0.xy, r5, r4

degenerate:
    mov outnq, r0
    mov outcol, ones

    ; Accumulate vertex colour in r1
    ; r1 = mat_emi
    ;mov r1, mat_emi

    ; Here's where specular calculations would go

    ; Here's where diffuse calculations would go

    ; r1 += ambientColour * lightColour
    ;mov r2, lightClr
    ;mad r1, r2, mat_amb, r1

    ; Clamp r1 to a maximum of 1.0 when outputting
    ; outcol = min(r1, 1.0)
    ;min outcol, ones, r1

    ; Done!
    end
.end ; main
